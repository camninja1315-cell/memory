(() => {
  // Helper: Download Blob
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Generate a session UUID for the batch
  function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  const sessionId = uuidv4();

  // Collect all image references (if you have images mapped to numbers)
  // This is a stub: you can manually add or script extraction from the UI if available
  const images = [
    // Example image references, customize as needed!
    // { number: 1, description: "User message about file chunking.", referenced_in: [10] },
    // { number: 3, description: "Apollo chart showing buy/sell volume.", referenced_in: [42,43] },
    // ...
  ];

  // Collect key entities discussed (manually add as needed)
  const entities = [
    // { type: "coin", name: "Apollo", token_address: "SOL_XXXX", dex_link: "...", context: "Discussed in chronological_index 41,42" },
    // { type: "coin", name: "8BIT", token_address: "...", dex_link: "...", context: "Mentioned in chronological_index 50" }
    // ...
  ];

  // User preferences and session state (customize as needed)
  const userPreferences = {
    format: "YAML for issues",
    prioritize: "trading scripts, quantum metrics",
    style: "Maximal honesty, deep technical detail, proactive research"
  };

  // Session continuity and context blocks
  const sessionContext = {
    current_focus: "Quantum metrics, Solana meme coin trading, session analysis",
    open_questions: [
      "Why did Apollo dump despite buy volume?",
      "How to maximize scraper accuracy?"
    ],
    ongoing_analysis: ["Apollo", "8BIT"],
    session_state: {
      persona: "Atlas",
      response_style: "Maximal honesty, deep technical detail",
      in_progress: ["Analyze last buy/sell event"]
    },
    session_continuity: {
      is_continuation: true,
      previous_session_id: null, // Fill in if applicable
      next_session_expected: true
    },
    user_preferences: userPreferences
  };

  // AI session commands
  const aiCommands = [
    {
      type: "set_persona",
      target: "AI",
      details: "Switch to 'Atlas' expert persona for quantum metrics, technical research, and deep analysis."
    },
    {
      type: "auto_research",
      target: "AI",
      details: "Proactively research and update context to the year 2025 or latest available information for all topics."
    },
    {
      type: "allow_self_modification",
      target: "AI",
      details: "Treat user requests to 'research', 'change', 'update', or 'restructure' as explicit commands to alter the AI's strategies/persona/context."
    },
    {
      type: "context_restore",
      target: "AI",
      details: "Merge all messages from all parts into a single chronological history and use as session memory."
    },
    {
      type: "import_order",
      target: "AI",
      details: "Start at part 1 and proceed in order. Use chronological_index to maintain message sequence."
    }
  ];

  // Scrape all message containers
  const bubbles = document.querySelectorAll('.message-container.ChatMessage-module__chatMessage--mrG0f');
  const sessionData = [];
  let msgNum = 0;
  bubbles.forEach(bubble => {
    let sender = bubble.classList.contains('ChatMessage-module__user--D7H_T') ? 'user' :
                 bubble.classList.contains('ChatMessage-module__ai--l6YpD') ? 'copilot' : 'unknown';

    let text = "";
    let msgContent = bubble.querySelector('.ChatMessage-module__content--sWQll');
    if (msgContent) {
      let userMsg = msgContent.querySelector('.UserMessage-module__container--qQMdD');
      let copilotMsg = msgContent.querySelector('.markdown-body');
      text = userMsg ? userMsg.innerText : (copilotMsg ? copilotMsg.innerText : msgContent.innerText);
    }

    let codeBlocks = [];
    msgContent && msgContent.querySelectorAll('pre, code').forEach(cb => {
      codeBlocks.push(cb.innerText);
    });

    let files = [];
    msgContent && msgContent.querySelectorAll('.ReferenceToken-module__referenceToken--WsIyo').forEach(ref => {
      files.push(ref.innerText);
    });

    // For image reference, manually add image numbers if known for this msgNum
    sessionData.push({
      chronological_index: msgNum++,
      sender,
      text,
      codeBlocks,
      files
      // Optionally: images: [3] if this message references image 3
    });
  });

  // Export all as a single file for repo upload (or chunk if desired)
  const fileMeta = {
    meta: {
      session_id: sessionId,
      part_number: 1,
      total_parts: 1,
      next_part: null,
      purpose: "AI/LLM memory import",
      instructions: "Treat each message as a chronological chat bubble from camninja1315-cell and Atlas/Copilot. Use these files to restore full conversational context, update AI persona/strategy, and follow all session commands and context blocks. Start at part 1 and proceed in order.",
      generated_at: new Date().toISOString(),
      uploader: "camninja1315-cell"
    },
    context: sessionContext,
    commands: aiCommands,
    entities: entities,
    images: images,
    messages: sessionData
  };

  const chunkBlob = new Blob([JSON.stringify(fileMeta, null, 2)], {type: 'application/json'});
  downloadBlob(chunkBlob, `copilot_session_history_full.json`);

  console.log(`Exported copilot_session_history_full.json with all metadata, context, entities, images, and session memory.`);
})();

# Solana Trading Bot - Project Summary & Next Steps

**User:** @camninja1315-cell
**Last Update:** 2025-10-07 01:06:02 UTC
**Current Bot Version:** 4.3 - The Strategist

---

### Project Goal

The primary objective is to develop a sophisticated and profitable automated trading bot for Solana meme coins on the Photon platform. The bot operates as a Tampermonkey userscript, analyzing on-page data to make trading decisions.

### Development Journey So Far

1.  **Initial Versions (v1-v3):** The bot started with basic strategies like `REVERSAL_SCALP` and `BREAKOUT_SCALP`. Analysis of early trades revealed a critical flaw: these strategies were unreliable and often entered trades prematurely, leading to significant losses from "bull traps" and "fakeouts."

2.  **Version 4.1 - The Momentum-First Engine:**
    *   **Problem:** `REVERSAL_SCALP` was "catching a falling knife."
    *   **Solution:** We replaced the unreliable signals with a single, more robust strategy: `MOMENTUM_RIDE`. The goal was to stop *predicting* reversals and only trade with *confirmed* positive momentum (i.e., when the market state was already `PUMPING`).

3.  **Version 4.2 - The Momentum Guard:**
    *   **Problem:** While `MOMENTUM_RIDE` improved entries, it had no specific exit condition tied to its entry logic. If a pump failed immediately after entry, the bot would hold the trade all the way to the stop loss.
    *   **Solution:** We introduced the "Momentum Guard." This is a strategy-specific exit condition for `MOMENTUM_RIDE` trades. If the market state ceases to be `PUMPING` and the trade's profit is below a small threshold (3%), the bot exits immediately, preventing small failures from becoming large losses.

4.  **Version 4.3 - The Strategist (Current Version):**
    *   **Problem:** We needed a way to safely test the bot's refined logic in live market conditions without risking capital. Testing on slow, post-migration coins wasn't providing realistic data.
    *   **Solution:** We implemented a `PAPER_TRADING_MODE`. When enabled, the bot runs its full logic, logging all intended actions and sending Discord alerts, but does **not** execute any actual buy or sell transactions.

### Current Status

The bot is currently at **Version 4.3**.
*   It operates with the `MOMENTUM_RIDE` signal as its primary entry strategy.
*   It is protected by multiple exit conditions: a standard stop-loss and take-profit, a `Profit Stagnation` rule, and the crucial `Momentum Lost` guard.
*   It is configured to run in **Paper Trading mode** by default for safe, real-world testing.

### Next Steps

1.  **Deploy and Observe:** Run the Version 4.3 script in `PAPER_TRADING_MODE` on live, active coins. The goal is to let it run for an extended period to gather as much data as possible across different market conditions.
2.  **Collect Data:** Let the bot generate logs and Discord notifications for its paper trades (both entries and exits).
3.  **Analyze Performance:** In our next session, we will analyze the results of these paper trades to evaluate the effectiveness of the v4.2 and v4.3 changes. We will look for:
    *   Trades correctly exited by the "Momentum Guard."
    *   Profitable trades that were allowed to run.
    *   Any new failure patterns that emerge.
4.  **Refine Logic:** Based on the analysis, we will further refine the bot's parameters and logic.

---

### Current Code (Version 4.3)

```javascript
// ==UserScript==
// @name         Solana Meme Coin Trading Bot Logic
// @namespace    http://tampermonkey.net/
// @version      4.3
// @description  The Strategist. Introduces a PAPER_TRADING_MODE to allow for live testing of the bot's logic without executing real trades. Actions are logged and sent to Discord, marked as [PAPER TRADE].
// @author       camninja1315-cell & Copilot
// @match        https://photon-sol.tinyastro.io/en/lp/*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    function getTimestamp() { return new Date().toISOString().replace('T', ' ').substring(0, 19) + ' UTC'; }
    console.log(`[${getTimestamp()}] --- Solana Meme Coin Bot Initialized (v4.3 - The Strategist) ---`);

    const CONFIG = {
        // --- Core Settings ---
        PAPER_TRADING_MODE: true, // <<<< NEW IN V4.3: Set to 'false' to execute real trades.
        DISCORD_WEBHOOK_URL: "https://canary.discord.com/api/webhooks/1420920608992137267/T82i9UpYJRC8RxhDd399r72khFtV4aaKZIvaI4oBL-BVHcVeAR1MuMJPicZcpoUz6GL1",
        CHECK_INTERVAL_MS: 3000,

        // --- Pre-Trade Rules ---
        MIN_LIQUIDITY: 20000,
        MAX_TOP_10_HOLDERS_PCT: 30,
        MAX_BOT_HOLDERS_PCT: 50,

        // --- Exit Rules ---
        TAKE_PROFIT_PCT: 25,
        STOP_LOSS_PCT: -10,

        // --- State & Signal Analysis ---
        MC_HISTORY_LENGTH: 12,
        STATE_CHANGE_THRESHOLD_PUMP: 8,
        STATE_CHANGE_THRESHOLD_DUMP: -8,
        SIGNAL_CONFIRMATION_COUNT: 2,

        // --- Strategy-Specific Exits & Re-Entry ---
        PROFIT_STAGNATION_CHECKS: 5,
        PROFIT_STAGNATION_MIN_PNL: 5,
        MOMENTUM_LOST_EXIT_THRESHOLD_PNL: 3,
        RE_ENTRY_PULLBACK_PCT: -10,
        RE_ENTRY_MIN_WAIT_MS: 90000,
    };

    if (CONFIG.PAPER_TRADING_MODE) {
        console.log('%c[PAPER TRADING MODE ACTIVATED] No real trades will be executed.', 'color: #FFA500; font-weight: bold; font-size: 14px;');
    }

    // --- State Management ---
    let tradeState = { inTrade: false, tradeType: null, entryMarketCap: 0, peakPnl: 0, stagnationCounter: 0, marketCapHistory: [] };
    let coinMemory = {};
    let pendingSignal = { type: null, confirmationCount: 0 };

    // --- Data Scraping, State Analysis (Unchanged) ---
    function parseValue(text) { if (typeof text !== 'string') return null; let v = parseFloat(text.replace(/[\$,%]/g, '')); if (text.toUpperCase().includes('K')) v *= 1000; else if (text.toUpperCase().includes('M')) v *= 1000000; return isNaN(v) ? null : v; }
    function formatValue(num) { if (!num) return '$0'; if (num >= 1000000) return `$${(num / 1000000).toFixed(2)}M`; if (num >= 1000) return `$${(num / 1000).toFixed(1)}K`; return `$${num.toFixed(0)}`; }
    function getCoinVisualData() { const nameElement = document.querySelector('.p-show__pair__cur'); const imageElement = document.querySelector('.p-show__bar__thumb img'); return { name: nameElement ? nameElement.textContent.trim() : 'Unknown Coin', image: imageElement ? imageElement.src : '' }; }
    function getCoinData() { const d = {}; const getSecurityText = (kind) => (document.querySelector(`.js-security-item[data-kind="${kind}"]`)?.textContent || '').toLowerCase(); d.isLpBurned = (parseValue(getSecurityText('lp_burned_perc')) || 0) >= 99; d.isMintDisabled = getSecurityText('mint_authority') === 'disabled'; d.isFreezeDisabled = getSecurityText('freeze_authority') === 'disabled'; d.isDexPaid = getSecurityText('dex_s') === 'yes'; d.liquidity = parseValue(document.querySelector('.p-show__widget__td__value[data-cable-val="usdLiquidity"]')?.textContent); d.marketCap = parseValue(document.querySelector('.p-show__widget__td__value[data-cable-val="mktCapVal"]')?.textContent); d.holderCount = parseValue(document.querySelector('.g9zXUaTbC5ES7XkFmrU1 .WGklHEHuq_jyGniR8G8Q:first-child + .mJ9778uUx85rQLrNK_Mg')?.textContent); const b = parseValue(document.querySelector('.g9zXUaTbC5ES7XkFmrU1 .WGklHEHuq_jyGniR8G8Q:nth-child(3) + .mJ9778uUx85rQLrNK_Mg')?.textContent); d.top10HoldersPct = parseValue(document.querySelector('.g9zXUaTbC5ES7XkFmrU1 .WGklHEHuq_jyGniR8G8Q:nth-child(2) + .mJ9778uUx85rQLrNK_Mg')?.textContent); d.freshHolderPct = parseValue(document.querySelector('.g9zXUaTbC5ES7XkFmrU1 .WGklHEHuq_jyGniR8G8Q:nth-child(4) + .mJ9778uUx85rQLrNK_Mg')?.textContent); const i = document.querySelector('.c-info__content'); if (i) { d.txns = parseValue(i.querySelector(`[data-name="txns"]`)?.textContent); d.buyVol = parseValue(i.querySelector(`[data-name="buy_vol"]`)?.textContent); d.sellVol = parseValue(i.querySelector(`[data-name="sell_vol"]`)?.textContent); } d.buySellVolRatio = (d.sellVol > 0) ? (d.buyVol / d.sellVol) : 100; d.botHoldersPct = (d.holderCount > 0) ? (b / d.holderCount) * 100 : 0; d.isSecure = d.isLpBurned && d.isMintDisabled && d.isFreezeDisabled; d.ageInMinutes = parseValue(document.querySelector('.c-info__tab.js-info__tab:first-child .c-info__interval')?.textContent || ''); return d; }
    function analyzeCoinState(data, history) { if (history.length < CONFIG.MC_HISTORY_LENGTH) return 'ANALYZING'; const mcChangePct = ((data.marketCap - history[0]) / history[0]) * 100; if (mcChangePct > CONFIG.STATE_CHANGE_THRESHOLD_PUMP) return 'PUMPING'; if (mcChangePct < CONFIG.STATE_CHANGE_THRESHOLD_DUMP) return 'DUMPING'; if (Math.abs(mcChangePct) < 4) return 'CONSOLIDATING'; return 'NEUTRAL'; }

    // --- Strategy & Filter Set (Unchanged) ---
    function checkMomentumRide(data, state) { if (state === 'PUMPING' && data.buySellVolRatio > 1.2) { return 'MOMENTUM_RIDE'; } return null; }
    function checkDexPaidSpike(data, state) { if (data.isDexPaid && data.ageInMinutes <= 10 && state === 'PUMPING' && data.buyVol > data.sellVol) return 'DEX_SPIKE'; return null; }
    function checkRocketLaunch(data, state) { if (state === 'PUMPING' && data.freshHolderPct > 8 && data.buySellVolRatio > 1.2) return 'ROCKET'; return null; }
    function checkPreTradeRules(d) { return d.isSecure && d.liquidity > CONFIG.MIN_LIQUIDITY && d.top10HoldersPct < CONFIG.MAX_TOP_10_HOLDERS_PCT && d.botHoldersPct < CONFIG.MAX_BOT_HOLDERS_PCT; }
    function isPeakPump(data, state) { if (state === 'PUMPING' && data.buySellVolRatio < 1.1) { console.log(`[${getTimestamp()}] [FILTER] Peak Pump Detected. State is PUMPING, but buy/sell ratio (${data.buySellVolRatio.toFixed(2)}) is weakening. Ignoring signals.`); return true; } return false; }

    // --- Trade Execution (Now respects Paper Trading Mode) ---
    function enterTrade(data, type) {
        const prefix = CONFIG.PAPER_TRADING_MODE ? '[PAPER TRADE] ' : '';
        console.log(`%c[${getTimestamp()}] ${prefix}[ACTION] ENTER ${type} TRADE`, 'color: #00ff00; font-weight: bold;');
        console.log(`${prefix}Entry MC: ${formatValue(data.marketCap)} | State: ${data.state}`);

        if (!CONFIG.PAPER_TRADING_MODE) {
            // REAL BUY LOGIC WOULD GO HERE
            // e.g., clickBuyButton();
        }

        tradeState.inTrade = true; tradeState.tradeType = type; tradeState.entryMarketCap = data.marketCap; tradeState.peakPnl = 0; tradeState.stagnationCounter = 0;
        sendToDiscord('TRADE_ENTRY', { ...data, tradeType: type });
    }

    function monitorTrade(data, state) {
        const mcPnlPercent = ((data.marketCap - tradeState.entryMarketCap) / tradeState.entryMarketCap) * 100;
        const prefix = CONFIG.PAPER_TRADING_MODE ? '[PAPER TRADE] ' : '';
        console.log(`[${getTimestamp()}] ${prefix}[MONITOR] State: ${state} | Type: ${tradeState.tradeType} | PnL: ${mcPnlPercent.toFixed(2)}%`);

        if (mcPnlPercent <= CONFIG.STOP_LOSS_PCT) { exitTrade(data, `Stop Loss at ${mcPnlPercent.toFixed(2)}%`); return; }
        if (mcPnlPercent >= CONFIG.TAKE_PROFIT_PCT) { exitTrade(data, `Take Profit at ${mcPnlPercent.toFixed(2)}%`); return; }
        if (mcPnlPercent > tradeState.peakPnl) { tradeState.peakPnl = mcPnlPercent; tradeState.stagnationCounter = 0; }
        else if (mcPnlPercent > CONFIG.PROFIT_STAGNATION_MIN_PNL) { tradeState.stagnationCounter++; if (tradeState.stagnationCounter >= CONFIG.PROFIT_STAGNATION_CHECKS) { exitTrade(data, `Profit Stagnation at ${mcPnlPercent.toFixed(2)}%`); return; } }
        if (tradeState.tradeType === 'MOMENTUM_RIDE' && state !== 'PUMPING' && mcPnlPercent < CONFIG.MOMENTUM_LOST_EXIT_THRESHOLD_PNL) { exitTrade(data, `Momentum Lost at ${mcPnlPercent.toFixed(2)}%`); return; }
    }

    function exitTrade(data, reason) {
        const pnl = ((data.marketCap - tradeState.entryMarketCap) / tradeState.entryMarketCap) * 100;
        const prefix = CONFIG.PAPER_TRADING_MODE ? '[PAPER TRADE] ' : '';
        console.log(`%c[${getTimestamp()}] ${prefix}EXIT: ${reason}`, 'color: #ff0000; font-weight: bold;');

        if (!CONFIG.PAPER_TRADING_MODE) {
            // REAL SELL LOGIC WOULD GO HERE
            // e.g., clickSellButton();
        }

        const coinAddress = window.location.pathname.split('/').pop();
        coinMemory[coinAddress] = { lastExitMarketCap: data.marketCap, lastExitTimestamp: Date.now() };
        sendToDiscord('TRADE_EXIT', { ...data, reason, pnl });
        tradeState.inTrade = false; tradeState.tradeType = null;
    }

    function canReEnter(coinAddress, currentMarketCap) { const memory = coinMemory[coinAddress]; if (!memory) return true; if (Date.now() - memory.lastExitTimestamp < CONFIG.RE_ENTRY_MIN_WAIT_MS) return false; const pullbackPct = ((currentMarketCap - memory.lastExitMarketCap) / memory.lastExitMarketCap) * 100; if (pullbackPct > CONFIG.RE_ENTRY_PULLBACK_PCT) return false; console.log(`[${getTimestamp()}] Re-entry conditions met. Pullback of ${pullbackPct.toFixed(1)}% detected.`); return true; }

    async function sendToDiscord(eventType, data) {
        if (!CONFIG.DISCORD_WEBHOOK_URL || CONFIG.DISCORD_WEBHOOK_URL.includes("YOUR_WEBHOOK_URL")) return;
        const coinInfo = getCoinVisualData();
        const paperTradePrefix = CONFIG.PAPER_TRADING_MODE ? "[PAPER TRADE] " : "";
        const embed = { title: `${paperTradePrefix}Bot Event`, url: window.location.href, timestamp: new Date().toISOString(), footer: { text: `Solana Trading Bot v4.3` }, thumbnail: { url: coinInfo.image }, fields: [] };
        switch (eventType) {
            case 'TRADE_ENTRY': embed.title = `${paperTradePrefix}📈 Trade Entry: ${coinInfo.name}`; embed.color = 3447003; embed.fields.push({ name: 'Signal', value: data.tradeType, inline: true }, { name: 'Entry Market Cap', value: formatValue(data.marketCap), inline: true }, { name: 'Liquidity', value: formatValue(data.liquidity), inline: true }, { name: 'State', value: data.state, inline: false }); break;
            case 'TRADE_EXIT': const isProfit = data.pnl >= 0; embed.title = `${paperTradePrefix}${isProfit ? '✅' : '🚨'} Trade Exit: ${coinInfo.name}`; embed.color = isProfit ? 3066993 : 15158332; embed.fields.push({ name: 'Reason', value: data.reason, inline: true }, { name: 'Final PnL', value: `${data.pnl.toFixed(2)}%`, inline: true }, { name: 'Entry MC', value: formatValue(tradeState.entryMarketCap), inline: true }, { name: 'Exit MC', value: formatValue(data.marketCap), inline: true }, { name: 'State', value: data.state, inline: false }); break;
        }
        if (embed.fields.length === 0) return;
        try { await fetch(CONFIG.DISCORD_WEBHOOK_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ embeds: [embed] }) }); } catch (error) { console.error(`[${getTimestamp()}] Failed to send Discord webhook:`, error); }
    }

    // --- Main Loop ---
    function main() {
        const data = getCoinData();
        if (!data || data.marketCap === null) { console.warn(`[${getTimestamp()}] Waiting for essential page data...`); return; }
        tradeState.marketCapHistory.push(data.marketCap);
        if (tradeState.marketCapHistory.length > CONFIG.MC_HISTORY_LENGTH) { tradeState.marketCapHistory.shift(); }
        data.state = analyzeCoinState(data, tradeState.marketCapHistory);
        if (!tradeState.inTrade) {
            const prefix = CONFIG.PAPER_TRADING_MODE ? '[PAPER] ' : '';
            console.log(`[${getTimestamp()}] ${prefix}[ANALYSIS] State: %c${data.state}`, 'font-weight: bold;');
            if (isPeakPump(data, data.state)) { pendingSignal = { type: null, confirmationCount: 0 }; return; }
            if (canReEnter(window.location.pathname.split('/').pop(), data.marketCap) && checkPreTradeRules(data)) {
                let currentSignal = checkMomentumRide(data, data.state) || checkRocketLaunch(data, data.state) || checkDexPaidSpike(data, data.state);
                if (currentSignal) {
                    if (pendingSignal.type === currentSignal) {
                        pendingSignal.confirmationCount++;
                        console.log(`[SIGNAL CONFIRMATION] Signal ${currentSignal} confirmed (${pendingSignal.confirmationCount}/${CONFIG.SIGNAL_CONFIRMATION_COUNT}).`);
                        if (pendingSignal.confirmationCount >= CONFIG.SIGNAL_CONFIRMATION_COUNT) { enterTrade(data, currentSignal); pendingSignal = { type: null, confirmationCount: 0 }; }
                    } else { pendingSignal = { type: currentSignal, confirmationCount: 1 }; console.log(`[SIGNAL SPOTTED] New signal ${currentSignal} found. Awaiting confirmation...`); }
                } else { if (pendingSignal.type) { console.log(`[SIGNAL LOST] Signal ${pendingSignal.type} was lost.`); } pendingSignal = { type: null, confirmationCount: 0 }; }
            }
        } else { monitorTrade(data, data.state); }
    }

    setInterval(main, CONFIG.CHECK_INTERVAL_MS);
})();
```
